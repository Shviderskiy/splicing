<!-- http://www.splice-design.com/wp-content/uploads/2010/03/SPL_logo2.png -->
<img 
    src="http://www.root6.com/wp-content/uploads/2015/12/Splice_logo.jpg.png"
	href="https://github.com/Shviderskiy/splicing"
    align="right"
    hspace="20px"
/>

## Обзор
Инструмент для перехвата любой функции (или инструкции по определенному адресу) в пользовательском пространстве при помощи техники [splicing](https://ru.wikipedia.org/wiki/Перехват_(программирование)#.D0.A1.D0.BF.D0.BB.D0.B0.D0.B9.D1.81.D0.B8.D0.BD.D0.B3).


## Простой пример
Все файлы, необходимые для примера, расположены в директории `example`. Для запуска будет использован механизм предварительной загрузки разделяемых библиотек в адресное пространство процесса при помощи переменной окружения [LD_PRELOAD](https://habrahabr.ru/post/199090/).

### Подготовка
Перед началом использования стоит отключить механизм защиты [ASLR](https://ru.wikipedia.org/wiki/ASLR), поскольку адреса перехвата должны иметь постоянные значения при каждом запуске процесса.

`sudo echo 0 > /proc/sys/kernel/randomize_va_space`

Вычисление адресов инструкций на основании смещений относительно точки входа не являлось основной целью.
Подобную логику предлагается реализовать самостоятельно.

### Сборка
Подготовка к сборке.

	user:~# git clone https://github.com/Shviderskiy/splicing.git ~/splicing
	user:~# cd ~/splicing/example

Сборка тестового исполняемого файла.
 
	user:~/splicing/example$ make foo

Сборка тестовой библиотеки для перехвата.
 
	user:~/splicing/example$ make lib

Запуск исполняемого файла с библиотекой перехвата.
 
	user:~/splicing/example$ make run

> *Запуск с огромной вероятностью произойдет некорректно! См. раздел Использование.*

### Использование
Для примера будем перехватывать функцию `bar` из `foo.cpp`.

	int bar(int param) {

    	printf("-> bar [executable]\n");
    	printf("   param =  %d\n", param);
    	return param + 1;
	}

Создадим исполняемый файл `foo`

	user:~/splicing/example$ make foo

и запустим чтобы посмотреть адрес функции `bar`.

	user:~/splicing/example$ ./foo
	-> main [executable]
   	   LD_PRELOAD not found
       &bar = 0x80484fd
	-> bar [executable]
       param  = 100500
       result = 100501

> *Посмотреть адрес можно также при помощи gdb.*

Видно, что функция `bar` вызвалась с указанными в `foo.cpp` параметрами.

	int result = bar(100500);

Теперь укажем в файле `init.cpp`, что нас интересует адрес `0x80484fd`.

	static int(*exetern_bar)(int) = 
	    reinterpret_cast<int(*)(int)>(0x80484fd);

Код, отвечающий за установку хука, находится в функции `init()`.

	splicing::api().setHook(reinterpret_cast<void*>(exetern_bar),
	                        reinterpret_cast<void*>(my_bar));

При вызове оригинальной функции `bar` в процессе `foo`, управление будет передано на определенную нами функцию `my_bar` в разделяемой библиотеке. 

Обе функции `bar` и `my_bar` имеют одинаковую сигнатуру, и, для простоты, сборка происходит с одними и теми-же флагами, а значит [прологи](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BB%D0%BE%D0%B3_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B) обеих функций не будут отличаться.

> *Обработчиком хука не обязательно должна быть функция. Существует возможность передать управление по произвольному адресу, например на ассемблерную вставку. Но не стоит забывать, что в этом случае, следить за сохранностью стека придется самостоятельно.*

Если потребуется вызвать оригинальную функцию `bar`, то необходимо восстановить ее содержимое.

	splicing::api().restore(reinterpret_cast<void*>(exetern_bar));

После восстановления оригинальной функции, в нее можно передать в любой параметр.

	int fictive_param = 400;
	return exetern_bar(fictive_param);

Для того чтобы увидеть результат нужно собрать библиотеку и запустить исполняемый файл с `LD_PRELOAD`.

	user:~/splicing/example$ make lib
	user:~/splicing/example$ make run # LD_PRELOAD=./lib.so ./foo
	-> init [library]
   	   &my_bar = 0xb770b8dd
	-> main [executable]
	   LD_PRELOAD not found
       &bar = 0x80484fd
	-> my_bar [library]
   	   param = 100500
	-> bar [executable]
   	   param  = 400
   	   result = 401

Как видно, функция `init` была вызвана перед `main`, что позволило модифицировать код функции целевого процесса.

> *Важно! Разница любых двух адресов, на которые будут устанавливаться хуки, не должна превышать 16 байт на x64 системах и 10 байт на x86. Это ограничение обусловлено размером инструкции перехода. При несоблюдении данных рекомендаций произойдет наложение машинных кодов инструкций друг на друга. В результате дальнейшее поведение будет абсолютно непрогнозируемым. В лучшем случае произойдет нарушение доступа к памяти (Access violation) с последующим крахом программы.*


## Пример из реальной жизни
Данная техника также может быть использована для перехвата функций выделения и освобождения памяти. Например, перехватив функцию free мы можем очистить переданный блок памяти перед его освобождением.

Выбор подобного решения актуален, если нам необходимо поддержать безопасное хранение конфиденциальных данных в оперативной памяти у имеющегося проекта с большой кодовой базой, в котором данная возможность не была предусмотрена.

> *Важно! Поскольку будет перехвачена низкоуровневая функция, используемая во многих местах проекта, в том числе стандартной библиотекой, будут неизбежны проблемы с производительностью.*

Установку хука для функции `free` следует производить следующим образом.

	splicing::api().trySetHookUnsafe(
	        reinterpret_cast<void*>(free),
	        reinterpret_cast<void*>(freeHook),
            freeSavedRegion);

Необходимость в использовании `unsafe` методов обусловлена тем, что другие методы в своей реализации неявно совершают вызовы `malloc` и `free`.

Возможная реализация функции `freeHook`.  

	void freeHook(void *pointer) {

	    splicing::api().tryRestoreUnsafe(
	            reinterpret_cast<void*>(free),
	            freeSavedRegion);
	
	    cleanMemory(pointer, size);
	    free(pointer);
	
	    splicing::api().trySetHookUnsafe(
	            reinterpret_cast<void*>(free),
	            reinterpret_cast<void*>(freeHook),
	            freeSavedRegion);
	}

Для полноценного функционирования данного примера потребуется обеспечить хранение размеров выделенных блоков. Чтобы это сделать придется перехватывать вызовы `malloc`.

>*Важно Данный пример не претендует на полноту! Он решает только половину проблем, связанных с безопасным хранением данных. Для достижения целостного решения следует устранить проблемы с хранением данных на стеке и запретить выгрузку страниц памяти в своп-файл.*


## Системные требования и необходимое окружение

### Поддерживаемые архитектуры процессоров
* x86
* amd64

### Поддерживаемые операционные системы
* Windows
* Linux

### Поддерживаемые компиляторы
* gcc
* clang
* mingw

